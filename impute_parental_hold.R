# impute parental haplotypes to hold while MARCC is down 

library(tidyverse)
library(dplyr)

#input_file <- "~/work/rmccoy22/mccarroll-sperm-seq-data/nc10oldoil/data/nc10oldoil_goodcellsreplicatebcs_filteredhetsnps_21.cellsbyrow.txt"
input_file <- "/Users/saracarioscia/mccoy-lab/nc10oldoil_goodcellsreplicatebcs_filteredhetsnps_21.cellsbyrow.txt"
window_length <- 2500

# load the data 
dt <- read_delim(input_file, delim = "\t") %>% 
  pivot_wider(., names_from = "cell", values_from = "gt") %>%
  arrange(., pos) %>% 
  as.data.frame()

# remove the first column (positions)
positions <- dt[, 1]
dtDa <- as.data.frame(dt[, -1])

# this function gets the mode of a vector after removing the NAs
getmode <- function(v) {
  uniqv <- unique(v)
  uniqv <- uniqv[!is.na(uniqv)]
  uniqv[which.max(tabulate(match(v, uniqv)))]
}

# this function replaces 0s with 1s and 1s with 0s in a data frame 
invertBits <- function(df) {
  df[df == 0] <- -1
  df[df == 1] <- 0
  df[df == -1] <- 1
  return(df)
}

# overlapping window function from https://stackoverflow.com/questions/8872376/split-vector-with-overlapping-samples-in-r
splitWithOverlap <- function(vec, seg.length, overlap) {
  starts = seq(1, length(vec), by=seg.length-overlap)
  ends   = starts + seg.length - 1
  ends[ends > length(vec)] = length(vec)
  
  lapply(1:length(starts), function(i) vec[starts[i]:ends[i]])
}

# use overlaps of window length/2
windows <- splitWithOverlap(rank(positions), window_length, overlap = window_length / 2)

# function to reconstruct parental haplotypes 
reconstruct_hap <- function(input_file, input_positions, window_indices) {
  
  window_start <- min(window_indices)
  window_end <- max(window_indices)
  
  positions_for_window <- input_positions[window_start:window_end]
  
  # compute a distance matrix
  d <- dist(t(as.matrix(dtDa)[window_start:window_end,]), method = "binary")
  # plut in 0.5 for any NA entries of the distance matrix
  d[is.na(d)] <- 0.5
  
  # cluster the distance matrix 
  tree <- hclust(d, method = "ward.D2")
  # plot(tree, cex = 0.1) # uncomment to plot
  # cut the tree generated by clustering into two groups (haplotypes)
  haplotypes <- cutree(tree, k=2)
  
  # get the names of the sperm cells falling into the two groups 
  h1_sperm <- names(haplotypes[haplotypes == 1])
  h2_sperm <- names(haplotypes[haplotypes == 2])
  
  # reconstruct the original haplotypes by majority vote after inverting the opposite haplotype
  h1_inferred <- unname(apply(cbind(dtDa[window_start:window_end, h1_sperm],
                                    invertBits(dtDa[window_start:window_end, h2_sperm])),
                              1, function(x) getmode(x)))
  h2_inferred <- unname(apply(cbind(dtDa[window_start:window_end, h2_sperm], 
                                    invertBits(dtDa[window_start:window_end, h1_sperm])),
                              1, function(x) getmode(x)))
  return(tibble(index = window_indices, pos = positions_for_window, h1 = h1_inferred))
}

# infer the haplotypes within the overlapping windows 
inferred_haplotypes <- lapply(1:length(windows), function(x) reconstruct_hap(input_file, positions, windows[[x]]))

# stitch together the haplotypes
initial_haplotype <- inferred_haplotypes[[1]]
for (hap_window in 2:length(windows)) {
  olap_haps <- merge(initial_haplotype, inferred_haplotypes[[hap_window]], by = "index")
  olap_haps_complete <- merge(initial_haplotype, inferred_haplotypes[[hap_window]], by = "index", all = TRUE)
  if (mean(olap_haps$h1.x == olap_haps$h1.y) < 0.1) {
    olap_haps_complete$h1.y <- invertBits(olap_haps_complete$h1.y)
  } else if (mean(olap_haps$h1.x == olap_haps$h1.y) < 0.9) {
    error("Haplotypes within overlapping windows are too discordant to merge.")
  }
  
  initial_haplotype <- tibble(index = olap_haps_complete$index, 
                              pos = c(olap_haps_complete[is.na(olap_haps_complete$pos.y),]$pos.x,
                                      olap_haps_complete[!is.na(olap_haps_complete$pos.x) & 
                                                           !is.na(olap_haps_complete$pos.y),]$pos.x,
                                      olap_haps_complete[is.na(olap_haps_complete$pos.x),]$pos.y),
                              h1 = c(olap_haps_complete[is.na(olap_haps_complete$pos.y),]$h1.x,
                                     olap_haps_complete[!is.na(olap_haps_complete$pos.x) &
                                                          !is.na(olap_haps_complete$pos.y),]$h1.x,
                                     olap_haps_complete[is.na(olap_haps_complete$pos.x),]$h1.y))
}
complete_haplotypes <- initial_haplotype %>% mutate(h2 = invertBits(h1))


## Re-code each sperm using the information from complete_haplotypes above 

# Duplicate dataframe of sperm to work with 
dt2 <- dt

# Going through each sperm, if an allele (0 or 1) in a sperm matches the allele (0 or 1) 
# in h1 at that position, replace the allele with "h1". Do the same for h2. 
for (i in 1:ncol(dt2)) {
  dt2[i][dt2[i]==complete_haplotypes$h1] <- "h1"
  dt2[i][dt2[i]==complete_haplotypes$h2] <- "h2"
}


# The HMM package cannot interact with NA values. 
# So, for each sperm, we want to select only the rows that don't have NA. 
# We keep the first column, which has the position of the SNP; 
# and we keep the column of that given sperm. 
# This generates a two-column dataframe for each sperm
for (i in 2:ncol(dt2)) {
  cols <- c(1, i)
  sperm <- data.frame(dt2[cols]) # Sperm is now a dataframe 
  sperm <- na.omit(sperm) # Sperm now gives just h1 and h2 values 
  assign(paste("sperm", i, sep = "."), sperm)
}

# Scan sperm by sperm to interpret state given emission

# First, we initialize our HMM

# load HMM package
library(HMM)

# set denominator for transition probability - one recombination event per chromosome
num_snps <- nrow(complete_haplotypes)

# two states
states <- c("haplotype1", "haplotype2")

# probability of state at position x+1 given state at position x   
hap1Prob <- c(1-(1/num_snps), 1/num_snps)
hap2Prob <- c(1/num_snps, 1-(1/num_snps))

transProb <- matrix(c(hap1Prob, hap2Prob), 2)

# Two emissions (observations): an allele from h1 or an allele from h2
emissions <- c("h1","h2")

# Prob of emitting an h1 allele, prob of emitting an h2 allele in state `haplotype1`
h1ProbEmiss <- c(.995, .005)
# Prob of emitting an h1 allele, prob of emitting an h2 allele in state `haplotype2`
h2ProbEmiss <- c(.005, .995)

emissProb <- matrix(c(h1ProbEmiss, h2ProbEmiss), 2)


#build model with the above inputs
hmm <- initHMM(States = states,
               Symbols = emissions,
               transProbs = transProb,
               emissionProbs = emissProb)

###### Function to run HMM on an input file 

# Compute the inferred state using each sperm cell as the input 
# (Input must be a vector)


runHMM <- function(sperm_file) {
  inferred_state <- viterbi(hmm, as.vector(sperm_file[[2]]))
  predState <- data.frame(Element = sperm_file, State = inferred_state)
  sperm_name <- colnames(predState)[2]
  sperm_name <- gsub("Element.", "", sperm_name)
  predState <- predState[, -2]
  colnames(predState)[2] <- sperm_name
  return(predState)
}

# this works 
runHMM(sperm.8)

# This works 
dfList <- list(sperm.2, sperm.3)
result <- lapply(dfList, function(sperm_file) runHMM(sperm_file))


# This  list works but throws an error in the HMM: 
#  Error in hmm$emissionProbs[state, observation[1]] : subscript out of bounds 
dfList3 <- lapply(ls(pattern="sperm\\."), function(x) get(x))
dfList3 <- dfList3[-1]

result <- lapply(dfList3, function(x) runHMM(x))

mymerge <- function(x, y) {
  merge(x, y, all = TRUE, by = "Element.pos")
}

test <- Reduce(mymerge, result) %>%
  rename("snp.position" = "Element.pos")
  


# Try fill function: 
# https://tidyr.tidyverse.org/reference/fill.html

sample <- tibble(sperm = c(NA, 0, NA, NA, NA, 0, NA, NA, NA, 1, NA, 1, NA)) %>%
  mutate(sperm_up = sperm) %>%
  mutate(sperm_down = sperm) %>%
  fill(sperm_up, .direction = "up") %>%
  fill(sperm_down, .direction = "down") %>%
  mutate(is_match = (sperm_up == sperm_down)) %>%
  replace_na(list(is_match = FALSE))
sample$sperm_imputed <- as.numeric(NA)
sample[sample$is_match == TRUE,]$sperm_imputed <- sample[sample$is_match == TRUE,]$sperm_up


sample <- tibble(sperm = c(NA, 2, NA, NA, NA, 2, NA, NA, NA, 3, NA, 3, NA)) %>%
  mutate(sperm_up = sperm) %>%
  mutate(sperm_down = sperm) %>%
  fill(sperm_up, .direction = "up") %>%
  fill(sperm_down, .direction = "down") %>%
  mutate(is_match = (sperm_up == sperm_down)) %>%
  replace_na(list(is_match = FALSE))
sample$sperm_imputed <- as.numeric(NA)
sample[sample$is_match == TRUE,]$sperm_imputed <- sample[sample$is_match == TRUE,]$sperm_up
