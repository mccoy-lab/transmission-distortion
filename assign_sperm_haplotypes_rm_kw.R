library(tidyverse)
library(pbapply)
library(pbmcapply)
library(HMM)

args <- commandArgs(trailingOnly = TRUE)
input_file <- args[1]
sampleName <- args[2]
chrom <- args[3]
outDir <- args[4]
seqError <- as.numeric(args[5]) #0.005
hapProb <- 1 - seqError
threads <- as.integer(args[6])
window_length <- as.integer(args[7]) #2500 default, if error raised -- retry with 1000 and 5000 also

# load the data
dt <- read_delim(input_file, delim = "\t") %>%
  pivot_wider(., names_from = "cell", values_from = "gt") %>%
  arrange(., pos) %>%
  as.data.frame()

# remove the first column (positions)
positions <- dt[, 1]
dt <- dt[,-1]

# this function gets the mode of a vector after removing the NAs
getmode <- function(v) {
  uniqv <- unique(v)
  uniqv <- uniqv[!is.na(uniqv)]
  uniqv[which.max(tabulate(match(v, uniqv)))]
}


# this function replaces 0s with 1s and 1s with 0s in a data frame
invertBits <- function(df) {
  df[df == 0] <- -1
  df[df == 1] <- 0
  df[df == -1] <- 1
  return(df)
}

# overlapping window function from https://stackoverflow.com/questions/8872376/split-vector-with-overlapping-samples-in-r
splitWithOverlap <- function(vec, seg.length, overlap) {
  starts = seq(1, length(vec), by=seg.length-overlap)
  ends   = starts + seg.length - 1
  ends[ends > length(vec)] = length(vec)
  lapply(1:length(starts), function(i) vec[starts[i]:ends[i]])
}

# use overlaps of window length/2
windows <- splitWithOverlap(rank(positions), window_length, overlap = window_length / 2)

# function to reconstruct parental haplotypes
reconstruct_hap <- function(input_dt, input_positions, window_indices) {
  window_start <- min(window_indices)
  window_end <- max(window_indices)
  positions_for_window <- input_positions[window_start:window_end]
  # compute a distance matrix
  d <- dist(t(as.matrix(input_dt)[window_start:window_end,]), method = "binary")
  # plut in 0.5 for any NA entries of the distance matrix
  d[is.na(d)] <- 0.5
  # cluster the distance matrix
  tree <- hclust(d, method = "ward.D2")
  # plot(tree, cex = 0.1) # uncomment to plot
  # cut the tree generated by clustering into two groups (haplotypes)
  haplotypes <- cutree(tree, k=2)
  # get the names of the sperm cells falling into the two groups
  h1_sperm <- names(haplotypes[haplotypes == 1])
  h2_sperm <- names(haplotypes[haplotypes == 2])
  # reconstruct the original haplotypes by majority vote after inverting the opposite haplotype
  h1_inferred <- unname(apply(cbind(input_dt[window_start:window_end, h1_sperm],
                                    invertBits(input_dt[window_start:window_end, h2_sperm])),
                              1, function(x) getmode(x)))
  h2_inferred <- unname(apply(cbind(input_dt[window_start:window_end, h2_sperm],
                                    invertBits(input_dt[window_start:window_end, h1_sperm])),
                              1, function(x) getmode(x)))
  return(tibble(index = window_indices, pos = positions_for_window, h1 = h1_inferred))
}

# infer the haplotypes within the overlapping windows
inferred_haplotypes <- pbmclapply(1:length(windows), 
                                  function(x) reconstruct_hap(dt, positions, windows[[x]]),
                                  mc.cores = getOption("mc.cores", threads))

# stitch together the haplotypes
initial_haplotype <- inferred_haplotypes[[1]]
for (hap_window in 2:length(windows)) {
  olap_haps <- merge(initial_haplotype, inferred_haplotypes[[hap_window]], by = "index")
  olap_haps_complete <- merge(initial_haplotype, inferred_haplotypes[[hap_window]], by = "index", all = TRUE)
  mean_concordance <- mean(olap_haps$h1.x == olap_haps$h1.y)
  if (mean_concordance < 0.1) {
    olap_haps_complete$h1.y <- invertBits(olap_haps_complete$h1.y)
  } else if (mean_concordance < 0.9) {
    error(paste0("Haplotypes within overlapping windows are too discordant to merge. Mean: ", mean_concordance))
  }
  initial_haplotype <- tibble(index = olap_haps_complete$index,
                              pos = c(olap_haps_complete[is.na(olap_haps_complete$pos.y),]$pos.x,
                                      olap_haps_complete[!is.na(olap_haps_complete$pos.x) &
                                                           !is.na(olap_haps_complete$pos.y),]$pos.x,
                                      olap_haps_complete[is.na(olap_haps_complete$pos.x),]$pos.y),
                              h1 = c(olap_haps_complete[is.na(olap_haps_complete$pos.y),]$h1.x,
                                     olap_haps_complete[!is.na(olap_haps_complete$pos.x) &
                                                          !is.na(olap_haps_complete$pos.y),]$h1.x,
                                     olap_haps_complete[is.na(olap_haps_complete$pos.x),]$h1.y))
}
complete_haplotypes <- initial_haplotype %>%
  mutate(h2 = invertBits(h1))

# Going through each sperm, if an allele (0 or 1) in a sperm matches the allele (0 or 1)
# in h1 at that position, replace the allele with "h1". Do the same for h2.
for (i in 1:ncol(dt)) {
  dt[i][dt[i] == complete_haplotypes$h1] <- "h1"
  dt[i][dt[i] == complete_haplotypes$h2] <- "h2"
}

# Scan sperm by sperm to interpret state given emission
# First, we initialize our HMM
# set denominator for transition probability - one recombination event per chromosome
num_snps <- nrow(complete_haplotypes)
# two states
states <- c("haplotype1", "haplotype2")
# probability of state at position x+1 given state at position x
hap1Prob <- c(1-(1/num_snps), 1/num_snps)
hap2Prob <- c(1/num_snps, 1-(1/num_snps))
transProb <- matrix(c(hap1Prob, hap2Prob), 2)

# Two emissions (observations): an allele from h1 or an allele from h2
emissions <- c("h1","h2")
# Prob of emitting an h1 allele, prob of emitting an h2 allele in state `haplotype1`
h1ProbEmiss <- c(hapProb, seqError)
# Prob of emitting an h1 allele, prob of emitting an h2 allele in state `haplotype2`
h2ProbEmiss <- c(seqError, hapProb)
emissProb <- matrix(c(h1ProbEmiss, h2ProbEmiss), 2)

#build model with the above inputs
hmm <- initHMM(States = states,
               Symbols = emissions,
               transProbs = transProb,
               emissionProbs = emissProb)

###### Function to run HMM on an input file
# Compute the inferred state using each sperm cell as the input
# (Input must be a vector)

runHMM <- function(sperm_dt, column_index) {
  original_obs <- sperm_dt[,column_index]
  inferred_state <- viterbi(hmm, na.omit(sperm_dt[, column_index]))
  original_obs[!is.na(original_obs)] <- inferred_state
  return(original_obs)
}

imputed_sperm <- as_tibble(do.call(cbind, pbmclapply(1:ncol(dt),
                                                     function(x) runHMM(dt, x),
                                                     mc.cores = getOption("mc.cores", threads))))

colnames(imputed_sperm) <- colnames(dt)

# Works on our sperm! Need to make the function work on every sperm in test3
# and need to make fill up and down at the end
fill_NAs <- function(merged_sperm, col_index) {
  sperm_sample <- merged_sperm[,col_index] %>%
    rename(sperm = colnames(.)[1]) %>%
    mutate(sperm_up = sperm) %>%
    mutate(sperm_down = sperm) %>%
    fill(sperm_up, .direction = "up") %>%
    fill(sperm_down, .direction = "down") %>%
    mutate(is_match = (sperm_up == sperm_down)) %>%
    replace_na(list(is_match = FALSE))
  sperm_sample$sperm_imputed <- as.character(NA)
  sperm_sample[sperm_sample$is_match == TRUE,]$sperm_imputed <- sperm_sample[sperm_sample$is_match == TRUE,]$sperm_up
  
  #fill beginning of chromosome NA's
  first <- which(!is.na(sperm_sample$sperm_imputed))[1]
  sperm_sample$sperm_imputed[1:(first-1)] <- sperm_sample$sperm_imputed[first]
  #fill end of chromosome NA's
  sperm_sample$sperm_imputed <- rev(sperm_sample$sperm_imputed)
  first <- which(!is.na(sperm_sample$sperm_imputed))[1]
  sperm_sample$sperm_imputed[1:(first-1)] <- sperm_sample$sperm_imputed[first]
  #reverse chromosome imputation back so it faces the right way
  sperm_sample$sperm_imputed <- rev(sperm_sample$sperm_imputed)
  return(sperm_sample$sperm_imputed)
}

filled_sperm <- as_tibble(do.call(cbind, 
                                  pblapply(1:ncol(imputed_sperm),
                                              function(x) fill_NAs(imputed_sperm, x))))
colnames(filled_sperm) <- colnames(dt)

td_test <- function(sperm_matrix, row_index) {
  test_row <- sperm_matrix[row_index,]
  gt_vector <- unlist(test_row)[-1]
  one_count <- sum(gt_vector == "haplotype1", na.rm = TRUE)
  two_count <- sum(gt_vector == "haplotype2", na.rm = TRUE)
  p_value <- binom.test(c(one_count, two_count))$p.value
  return(c(p_value, one_count, two_count))
}

df_counts_pvals <- do.call(rbind, pbmclapply(1:nrow(filled_sperm), 
                                             function(x) td_test(filled_sperm, x),
                                             mc.cores=getOption("mc.cores", threads))) %>%
  as_tibble() %>% 
  add_column(positions) #bind the positions vector to df_counts_pvals

colnames(df_counts_pvals) <- c("pval", "h1_count", "h2_count", "genomic_position")

filename_df <- paste0(outDir, sampleName, "_", chrom, "_pval.csv")
write.csv(df_counts_pvals, filename_df)

#find recombination spots
find_recomb_spots <- function(input_matrix, x, identities, genomic_positions){
  input_vec <- input_matrix[, x]
  ident <- identities[x]
  single_rs <- FALSE #single recombination spot only
  
  recomb_spots <- c() #initialize empty list
  
  na_locs <- which(is.na(input_vec)) #which locations have NAs
  num_na_locs <- sum(is.na(input_vec)) #how many NAs
  rle_result <- rle(input_vec)
  
  hap_locs <- which(!is.na(rle_result$values)) #which locations from the rle result are haplotypes
  neighboring_haps <- diff(hap_locs)
  lens_fresult <- lapply(rle_result["lengths"], cumsum)$lengths
  if (length(neighboring_haps) > 0) { #this section is in case there is at least one recombination spot without NAs buffering it, but there are NAs buffering others
    for (i in 1:length(neighboring_haps)) {
      if (neighboring_haps[i] == 1){
        rspot_end_loc <- lens_fresult[hap_locs[i+1]] #because of the cumsum, this gives us the index
        recomb_spots <- rbind(recomb_spots, c(ident, genomic_positions[rspot_end_loc-1], genomic_positions[rspot_end_loc]))
      }
    }
  }
  
  if ((num_na_locs == 0) & (length(rle_result$values) == 1)) { #no recombination spots at all
    recomb_spots <- as_tibble(cbind(ident, "None", "None"))
    colnames(recomb_spots) <- c("Ident", "Genomic_Start", "Genomic_End")
    return (recomb_spots)
  }
  
  if ((num_na_locs == 0) & (length(rle_result$values) > 1)) {#recombination spots, but no NA's buffering them
    recomb_spot_starts <- lapply(rle_result["lengths"], cumsum)$lengths[1:length(rle_result$values)-1]
    recomb_spot_ends <- recomb_spot_starts + 1
    recomb_spots <- as_tibble(cbind(ident, genomic_positions[recomb_spot_starts], genomic_positions[recomb_spot_ends]))
    colnames(recomb_spots) <- c("Ident", "Genomic_Start", "Genomic_End")
    return (recomb_spots)
  }
  
  neighboring_difs <- diff(na_locs)
  
  subsetted_na_locs <- c(na_locs[1])
  for (i in 2:length(na_locs)){
    if (neighboring_difs[i-1] != 1){ #grab locations of "new" NAs that aren't right next to other NAs
      subsetted_na_locs <- cbind(subsetted_na_locs, na_locs[i]) #need this for when we have different number of NAs buffering, especially more than 1 between the different haplotypes
    }
  }
  
  first_na_loc <- subsetted_na_locs[1] #first NA loc, this variable will be overwritten in the while loop
  first_na_loc_fi <- first_na_loc #copying variable to use it for static indexing later
  last_na_loc <- na_locs[length(na_locs)] #last NA loc in full input
  i <- 1 #start incremental counter
  
  if ((last_na_loc - first_na_loc + 1) == num_na_locs) { #there's a single recombination spot
    single_rs <- TRUE
    if (input_vec[first_na_loc-1] != input_vec[last_na_loc + 1]) {# verify haplotypes are different
      recomb_spots <- rbind(recomb_spots, c(ident, genomic_positions[first_na_loc-1], genomic_positions[last_na_loc+1])) #store recombination spot
    } else {stop(paste0("Haplotypes surrounding single set of NAs match but mistakenly appear to be a recombination spot at ", ident, genomic_positions[first_na_loc-1], " and ", genomic_positions[last_na_loc + 1]))}
  } else { #multiple recombination spots, all boundaries buffered by NAs
    
    while (((last_na_loc - first_na_loc +1) > num_na_locs) & (num_na_locs > 0)){ #first condition means there must be some haplotypes interspersed with all the NAs (i.e. there is more than one recombination spot); second condition means we've looped through and accounted for all of the NAs
      first_hp_loc <- which(!is.na(input_vec[first_na_loc_fi : last_na_loc]))[i] #this will find the first haplotype location for each recombination spot unless it is the last, then it should return an NA; needs to be used in combo with static indexer because it's relative to number of NAs left, not full input
      if (!is.na(first_hp_loc)) { #for all but the last recombination spot
        if (input_vec[first_na_loc -1] != input_vec[first_na_loc_fi + first_hp_loc -1]) { # verify haplotypes are different
          recomb_spots <- rbind(recomb_spots, c(ident, genomic_positions[first_na_loc -1], genomic_positions[first_na_loc_fi + first_hp_loc -1])) #add the genomic position boundaries of the recombination spot
        } else {stop(paste0("Haplotypes surrounding NAs match but mistakenly appear to be a recombination spot at ", ident, genomic_positions[first_na_loc -1], " and ", genomic_positions[first_na_loc_fi + first_hp_loc-1]))}
        
        i <- i +1 #add to incremental counter
        first_na_loc <- subsetted_na_locs[i] #find new first NA for next recombination spot
        num_na_locs <- sum(is.na(input_vec[(first_na_loc_fi + first_hp_loc-1):length(input_vec)])) #find new number of remaining/unaccounted for NAs
      }
      else { #reached last recombination spot, will add outside of the loop
        break
      }
    }
  }
  
  if (((last_na_loc - first_na_loc + 1) > 0) & !single_rs) { #add last recombination spot
    if (input_vec[first_na_loc -1] != input_vec[last_na_loc+1]) { #verify haplotypes are different
      recomb_spots <- rbind(recomb_spots, c(ident, genomic_positions[first_na_loc - 1], genomic_positions[last_na_loc+1]))
    } else {stop(paste0("Haplotypes surrounding last recombination spot NAs match but mistakenly appear to be a recombination spot at ", ident, genomic_positions[first_na_loc -1], " and ", genomic_positions[last_na_loc+1]))}
  }
  
  recomb_spots <- as_tibble(recomb_spots)
  colnames(recomb_spots) <- c("Ident", "Genomic_Start", "Genomic_End")
  
  return (recomb_spots)
  
}

idents_for_csv <- paste0(paste0(sampleName, "_", chrom, "_"), colnames(filled_sperm))

#recomb_spots_all <- do.call(rbind, pblapply(1:ncol(filled_sperm),
#                                            function(x) find_recomb_spots(filled_sperm, x, idents_for_csv, positions)))

recomb_spots_all <- do.call(rbind, pbmclapply(1:ncol(filled_sperm),
                                              function(x) find_recomb_spots(filled_sperm, x, idents_for_csv, positions),
                                              mc.cores=getOption("mc.cores", threads)))
filename_rs <- paste0(outDir, sampleName, "_", chrom, "_recombination_locs.csv")
write.csv(recomb_spots_all, filename_rs)
